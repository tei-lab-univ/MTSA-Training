range NUM_OF_SLOT = 1..3

PARK = EMPTY,
EMPTY = (in->FULL),
FULL = (request->outPK->EMPTY).

GATE = EMPTY,
EMPTY = ({inG, pt1toG, pt2toG}->FULL),
FULL = ({outG, gtoPT1, gtoPT2}->EMPTY).

Path1 = EMPTY,
EMPTY = ({p[1].outPK, gtoPT1, pt2toPT1}->FULL),
FULL = ({p[1].in, pt1toG, pt1toPT2}->EMPTY).

Path2 = EMPTY,
EMPTY = ({p[2].outPK, gtoPT2, pt1toPT2, pt3toPT2}->FULL),
FULL = ({p[2].in, pt2toG, pt2toPT1, pt2toPT3}->EMPTY).

Path3 = EMPTY,
EMPTY = ({p[3].outPK, pt2toPT3}->FULL),
FULL = ({p[3].in, pt3toPT2}->EMPTY).

||PARKS = (p[NUM_OF_SLOT]:PARK).
||ENV = (p[NUM_OF_SLOT]:PARK||GATE||Path1||Path2||Path3).

ltl_property NotReturnPT1=[](gtoPT1->X(!pt1toG W (p[1].in)))
ltl_property NotReturnPT2=[](gtoPT2->X(!pt2toG W (p[2].in)))
ltl_property NotReturnPT2=[](gtoPT3->X(!pt3to2 W (p[3].in)))

controllerSpec Spec = {
	safety = {NotReturnPT1}
	controllable = {p[NUM_OF_SLOT].in, p[NUM_OF_SLOT].out,  inG, outG, gtoPT1, gtoPT2, pt1toG, pt1toPT2, pt2toG, pt2toPT1, pt2toPT3, pt3toPT2}
}
controller ||Controller = (ENV)~{Spec}.